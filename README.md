# Руководство для начинающих

## 1. шаг 

[GIT](https://git-scm.com/download/win "скачать отсюда")

## 2. шаг

Установить командную строку Git и запустить Git Bash

## Команды

pwd - print currient directory;

cd - change directory;

.. - go to up level: example (cd ..);

. - go to currient directory: (cd .);

ls - print directoru stuff iles and othe directories);

ls -a - print all (with invizible files and directories);

touch - create new file;

mkdir - create new directory;

mkdir -p - create struct of directories: (mkdir -p first/second/third);

cp - copy files: (target target place); mv - move files (taget target place);

cat print file (only text); rn - remove file;

rmdir - remove directory (only empry directory);

rm -r - remove palce with stuff;

more information [Яндекс практикум](https://practicum.yandex.ru)

## 3. шаг

[GitHub](https://github.com)

В правом верхнем углу главной страницы GitHub нажмите на Sign up (англ. «зарегистрироваться»).

На экране будут последовательно появляться поля для ввода.

2.1. Введите адрес электронной почты (англ. Enter your email).

2.2. Придумайте пароль (англ. Create a password).

2.3. Введите имя пользователя (англ. Enter a username).

Платформа спросит, хотите ли вы получать на почту рассылку с обновлениями и новостями (англ. Would you like to receive product updates and announcements via email?).

Введите y, если хотите получать рассылку, или n, если не хотите.

Нажмите кнопку Continue (англ. «продолжить»).

GitHub предложит вам пройти капчу. Сделайте это.

После прохождения капчи нажмите Create account (англ. «создать аккаунт»).

Введите короткий код, который будет отправлен на указанный вами почтовый адрес.

## 4. шаг (Repository) 

Зайдите в свой профиль по ссылке https://github.com/username, где username — имя, которое вы указали при регистрации.

Эта страница — презентация вас и ваших проектов. Её видят другие пользователи. Надпись You don't have any public repositories yet (англ. «у вас пока нет публичных репозиториев») сообщает, что пока у вас нет проектов.  Создайте репозиторий. Для этого перейдите на вкладку Repositories (англ. «репозитории»), а затем нажмите на зелёную кнопку New (англ. «новый») справа.

Открылось окно создания нового репозитория. Назовите его first-project. Название удалённого репозитория необязательно должно совпадать с именем папки проекта у вас на компьютере. Но чтобы не путаться, будем называть их одинаково.

Другие поля вам пока не понадобятся. Смело нажимайте на зелёную кнопку Create repository (англ. «создать репозиторий») внизу.

## 5. шаг (SSH key)

Инструкция по генерации SSH-ключа

Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.

```bash
 ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.
    Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Ничего страшного: используйте другой алгоритм.

```bash 
ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
``` 

После ввода отобразится такое сообщение.

> Generating public/private rsa key pair. // сгенерированы публичный и приватный ключи

Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.

macOS

> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]

Windows

> Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter]

Теперь в указанной директории появится пара ключей.  Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.

> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again] 

Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду.

```bash
ls -a ~/.ssh
```

На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому!

## 6. шаг

Инструкция по связыванию SSH-ключа и GitHub-аккаунта

После выполнения команды ssh-keygen из предыдущего урока в директории ~/.ssh будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):

id_ed25519/id_rsa — приватный ключ (файл без .pub в конце). Ни в коем случае не копируйте его и не делитесь им.

id_ed25519.pub/id_rsa.pub — публичный ключ (на это указывает расширение .pub).  Скопируйте содержимое файла с публичным ключом в буфер обмена.

macOS

скопировать содержимое ключа в буфер обмена:
```bash
pbcopy < ~/.ssh/id_rsa.pub
```
для ed25519:
```bash
pbcopy < ~/.ssh/id_ed25519.pub 
```

Здесь используется команда pbcopy — она копирует поток данных в буфер обмена. Запись pbcopy < ~/.ssh/id_rsa.pub означает: «Скопируй в буфер обмена всё содержимое файла ~/.ssh/id_rsa.pub».

В качестве альтернативы вы можете распечатать файл на экран с помощью cat ~/.ssh/id_rsa.pub и скопировать его вручную.

Windows

скопировать содержимое ключа в буфер обмена:
```bash
 clip < ~/.ssh/id_rsa.pub
```
для ed25519:
```bash
clip < ~/.ssh/id_ed25519.pub
``` 

Если clip не сработает, выведите содержимое файла с помощью

```bash
cat ~/.ssh/id_rsa.pub
```

или

```bash
cat ~/.ssh/id_ed25519.pub
```

и скопируйте вывод в буфер обмена из консоли.

Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.

В меню слева нажмите на пункт SSH and GPG keys.

В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).

В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»). В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).

В поле Key скопируйте ваш ключ из буфера обмена.

Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).  Проверьте правильность ключа с помощью следующей команды.

```bash
ssh -T git@github.com
```

Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение.

The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? 

Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.

Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой ссылке. Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.

Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.

## 7. шаг

Привязать удалённый репозиторий к локальному — git remote add
Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно.
Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»).

```bash
cd ~/dev/first-project && git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git
```

Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.
💡 Как выполнить вставку в командную строку?
В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание Ctrl+Shift+V, а на macOS — Cmd+V.
Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.
origin (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.
Убедиться, что репозитории связаны, — git remote -v
Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.

```bash
git remote -v
```

origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)

origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)

## 8. шаг

Отправить изменения на удалённый репозиторий — _git push_

Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»).

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.

```bash
git push -u origin main
```

Если команда приведёт к ошибке, попробуйте - аменить main на _master_. 

Появится такой экран.

При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.

Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.

Зайдите в репозиторий first-project на GitHub. Вы увидите, что в репозитории появились файлы с изменениями.
В дальнейшем при работе с удалённым репозиторием флаг *-u* можно опустить и писать просто *git push*.

### Работа с графическим интерфейсом GitHub

GitHub предоставляет удобный интерфейс для работы с репозиторием. Например, нажмите на кнопку commit в правой части страницы, чтобы просмотреть все коммиты в репозитории.

Откроется окно с коммитами и их авторами.

Сообщение коммита в репозитории тоже является ссылкой. 

Перейдите по ссылке, кликните на текст последнего коммита над репозиторием — так вы сможете увидеть все изменения, которые были внесены в репозиторий в этом коммите. 

В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг *-v* — короткая форма флага *--verbose* (англ. «подробный»). Он позволяет показать больше информации в выводе.

## 9. шаг (Хеш — идентификатор коммита)

В процессе работы с Git вам будет часто встречаться понятие «хеш коммита». Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду git log и выводили историю коммитов.
В этом уроке разберём, что такое хеши и зачем они нужны.

### Что такое хеш. Хеширование коммитов

Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Обычно хеш — это короткая (4040 символов в случае SHA-1) строка, которая состоит из цифр 0—90—9 и латинских букв A—FA—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

 * если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
 * если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 на этом сайте — попробуйте ввести в поле input (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле output (англ. «вывод»).

### Хеш — основной идентификатор коммита

Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта. 

## шаг 10 (Исследуем лог)

В этом уроке рассмотрим подробнее, из каких элементов состоит описание коммита, а также как вывести сокращённый лог (от англ. log — «журнал [записей]»). Сокращённый лог полезен, если нужно быстро найти нужный коммит среди сотни других.

### Элементы описания коммита

После вызова git log появляется список коммитов.

Разберём элементы, из которых состоит описание:

    * строка из цифр и латинских букв после слова commit — это хеш коммита;
    * Author — имя автора и его электронная почта;
    * Date — дата и время создания коммита;
    * в конце находится сообщение коммита.

Исходный код самого Git тоже хранится в Git-репозитории (тут уместно вспомнить про курицу и яйцо). Вот так выглядит описание самого первого коммита в репозитории Git.

 Изучите его.

> commit e83c5163316f89bfbde7d9ab23ca2e25604af290

> Author: Linus Torvalds <torvalds@linux-foundation.org>

> Date:   Thu Apr 7 15:13:13 2005 -0700

   > Initial revision of "git", the information manager from hell 

### Получить сокращённый лог — >git log --oneline

Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

💡 Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской раскладке клавиатуры.

## шаг 11 (HEAD — всему голова)

При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов. В этом уроке расскажем, что она означает.

### Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.

```bash
pwd
```

посмотрели, где мы

```bash
 cd .git/

 ls
```

 посмотрели, какие есть файлы

```bash
cat HEAD 
```

ref: refs/heads/master # в файле вот такая ссылка 

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

```bash
cat refs/heads/master 
```

взяли ссылку из файла HEAD

внутри хеш
 * e007f5035f113f9abca78fe2149c593959da5eb7

```bash
git log 
```

сверяем с хешем последнего коммита

>commit e007f5035f113f9abca78fe2149c593959da5eb7

>Author: John Doe <johndoe@example.com>

>Date:   Tue Mar 28 00:26:53 2023 +0300

>    Добавить амбиций в список дел

>... # другие коммиты 

Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.

При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

## шаг 12 (Статусы файлов в Git)

До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог *git add*, а можно было просто сделать коммит (*svn commit*). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.

Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.

В этом уроке разберём подробнее, в каких состояниях (или статусах) могут находиться файлы в репозитории. А ещё проследим типичный жизненный цикл файла в Git.

### Статусы *untracked*/*tracked*, *staged* и *modified*

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

    * untracked (англ. «неотслеживаемый»)

Мы говорили, что новые файлы в Git-репозитории помечаются как *untracked*, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У *untracked*-файла нет предыдущих версий, зафиксированных в коммитах или через команду *git add*.

    * staged (англ. «подготовленный»)

После выполнения команды *git add* файл попадает в **staging area** (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии *staged*.

В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а *git commit* делает снимок всей сцены целиком.
 
>    💡 Staging area, index и cache

>    Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.

>    Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте [Stack Overflow](https://stackoverflow.com).

    * tracked (англ. «отслеживаемый»)

Состояние *tracked* — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью *git commit*, а также файлы, которые были добавлены в *staging* area командой *git add*. То есть все файлы, в которых Git так или иначе отслеживает изменения.

    * modified (англ. «изменённый»)

Состояние *modified* означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

💡 Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается.

### Про *staged* и *modified*

Команда *git add* добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете *git add file.txt*, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.

Git сообщит об этом с помощью статуса *modified*: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить *git add file.txt* ещё раз.

### Типичный жизненный цикл файла в Git

Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.

   1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.

   2. Файл добавили в staging area с помощью *git add*. Состояние: *staged* (+ *tracked*).

        * Возможно, изменили файл ещё раз. Состояния: *staged*, *modified* (+ *tracked*).
        * Обратите внимание: *staged* и *modified* у одного файла, но у разных его версий.
        * Ещё раз выполнили *git add*. Состояние: *staged* (+ *tracked*).

   3. Сделали коммит с помощью *git commit*. Состояние: *tracked*.

   4. Изменили файл. Состояние: *modified* (+ *tracked*).

   5. Снова добавили в staging area с помощью *git add*. Состояния: *staged* (+ *tracked*).

   6. Сделали коммит. Состояния: *tracked*.

   7, Повторили пункты 4−74−7 много-много раз.

Выглядит довольно запутанно! Но на практике разобраться с этим будет проще, чем кажется. Вы сможете наглядно проследить типичный жизненный цикл файла в Git в следующем уроке.

## шаг 13 (Как читать git status)

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого легко избежать, если не забывать проверять статусы файлов с помощью команды *git status*. Как читать её вывод, покажем в этом уроке.

### Какие состояния показывает *git status*

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды *git status* — иначе она бы каждый раз выводила список вообще всех файлов проекта.

В итоге *git status* показывает только следующие состояния файлов:
   
   * staged (Changes to be committed в выводе git status);
   * modified (Changes not staged for commit);
   * untracked (Untracked files).

### Подготавливаем репозиторий

Чтобы попрактиковаться, инициализируйте новый репозиторий *~/dev/git-status-lesson*. Создайте в нём файл *README.md* и закоммитьте его.

```bash
cd ~/dev &&
mkdir git-status-lesson &&
cd git-status-lesson &&
git init
```
тут Git выведет что-нибудь, но мы это пропустим

```bash
 touch README.md &&
 git add README.md &&
 git commit -m 'Добавить README'
```
по традиции первым создадим и закоммитим файл README.md 

Дальше вы будете добавлять в репозиторий файлы и смотреть на их статусы.

### Типичные варианты вывода *git status*

Рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

    1. **Нет ни** *staged*-**, ни** *modified*-**, ни** *untracked*-**файлов**.

Если ничего не менять в *git-status-lesson* после первого коммита, то в нём не должно быть ни изменённых файлов (*modified*), ни новых (untracked), ни добавленных в список на коммит (*staged*). Вызовите команду *git status*. Её вывод будет примерно таким.

```bash
git status
```
On branch master
nothing to commit, working tree clean  

Это означает, что в репозитории нет новых или изменённых файлов. Последняя строка *nothing to commit, working tree clean* буквально переводится как «нечего коммитить, рабочая директория чиста».
Первая строка *On branch master* сообщает, что текущая ветка — *master*.

   2. **Найдены неотслеживаемые файлы.**

Создайте в папке *~/dev/git-status-lesson* файл *fileA.txt*. Теперь в репозитории есть новый файл в состоянии *untracked*. Снова вызовите команду *git status*. Результат будет таким.

```bash
touch fileA.txt &&
git status
```

> On branch master

> Untracked files: # найдены неотслеживаемые файлы

>  (use "git add <file>..." to include in what will be committed)

>        fileA.txt

>nothing added to commit but untracked files present (use "git add" to track) 

Файл *fileA.txt* отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через *git add*.
💡 Обратите внимание: в самом выводе git status есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: **Use** *git add <file>* **to include in what will be committed** (англ. «используйте *git add <file>*, чтобы добавить в список на коммит»).

Добавьте *fileA.txt* в staging area с помощью *git add* и снова запросите *git status*.

```bash
git add fileA.txt && 
git status
```

> On branch master

> Changes to be committed: # новая секция

>  (use "git restore --staged <file>..." to unstage)

>        new file:   fileA.txt 

💡 В этот раз *git status* подсказывает, что существует команда *git restore*. Мы познакомим вас с ней в одном из будущих уроков.
Теперь *fileA.txt* находится в секции C*hanges to be committed* (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

```bash
git commit -m 'Добавить файл fileA.txt'
```

тут будет вывод комманды commit, он нас не интересует

```bash
git status 
```

> On branch master
. nothing to commit, working tree clean 

Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».

   3. **Найдены изменения, которые не войдут в коммит**

Теперь откройте файл *fileA.txt* и добавьте в него несколько слов — например, Это файл A!. Сохраните *fileA.txt* и вызовите команду *git status*. Её результат будет такой.

внесли в fileA.txt правки

запросили статус

```bash
git status
```
 
> On branch master

> Changes not staged for commit: # ещё одна секция

>  (use "git add <file>..." to update what will be committed)

>  (use "git restore <file>..." to discard changes in working directory)

>        modified:   fileA.txt 

Файл *fileA.txt* был изменён, но ещё не добавлен в staging area после этого. Так он оказался в секции *Changes not staged for commit* (англ. «изменения, которые не подготовлены к коммиту»). Эта секция соответствует статусу *modified*.
Подготовьте правки к коммиту с помощью *git add*.


```bash
git add fileA.txt && git status
```

> On branch master

> Changes to be committed: # все изменения готовы к коммиту

>  (use "git restore --staged <file>..." to unstage)

>        modified:   fileA.txt 

Теперь в коммит попадёт уже новая версия файла *fileA.txt*.

💡 Обратите внимание: хотя вывод команды *git status* очень похож на тот, который был после первого добавления файла *fileA.txt*, они всё же отличаются.

Когда совсем новый файл попадает в staging area, перед его названием указывается *new file*. Вот так: *new file: fileA.txt*.

Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения *git add* он будет записан уже так: *modified: fileA.txt*.

  4. **Файл добавлен в staging area, но после этого изменён**

Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. Например, вместо одного восклицательного знака в конце строки Это *файл A!* нужно поставить три.

Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать *git status*. Он покажет следующее.

изменили fileA.txt

```bash
git status
```

> On branch master

> Changes to be committed:

>  (use "git restore --staged <file>..." to unstage)

>          modified:   fileA.txt

> Changes not staged for commit:

>  (use "git add <file>..." to update what will be committed)

>  (use "git restore <file>..." to discard changes in working directory)

>          modified:   fileA.txt 

Файл попал и в *staged* (*Changes to be committed*), и в *modified* (*Changes not staged for commit*). В staging area находится версия файла с одним восклицательным знаком, а в C*hanges not staged for commit* — уже изменённая версия, с тремя.

Чтобы закоммитить самую свежую версию файла, нужно снова выполнить *git add* перед коммитом.

## шаг 14 (Оформление сообщений к коммитам) 

То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями.

Например, в выводе команды *git log --oneline* умещается максимум 7272 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 7272 символов».

В этом уроке рассмотрим несколько популярных подходов к оформлению сообщений коммитов. Но сначала разберём, почему такие сообщения важны и зачем соблюдать правила их оформления.

###Зачем вообще писать сообщения

У каждого коммита в Git есть сообщение — то, что передаётся после параметра *-m*. Например: *git commit -m "Добавить урок про оформление сообщений коммитов"*.

Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.

Как и надпись на коробке, сообщение коммита должно помочь определить, что внутри. Например, надпись на коробке «всякое разное» не очень полезная. Сообщение коммита «небольшие исправления» тоже: непонятно, что было исправлено в таком коммите и зачем.

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

    * относительно коротким, чтобы его было легко прочитать;
    * информативным.

Вот пример полезного сообщения в репозитории новостного сайта: Исправление *опечатки в заголовке главной страницы на хорватском*. Такое сообщение даёт много информации:
     
    * Исправление опечатки* значит, что исправлена ошибка, которая была допущена при наборе. Такое исправление не меняет смысл. То есть, например, главному редактору не нужно перепроверять этот заголовок.
    * На хорватском* говорит о том, что переводчикам на другие языки этот коммит можно смело пропускать.
    * В заголовке главной страницы* указывает, где произошли изменения. Если, например, кто-то зайдёт на сайт и ему не понравится новый заголовок, он легко найдёт по истории (git log) автора этого коммита и спросит у него, почему заголовок теперь такой.

Пример плохого сообщения для того же коммита: *Исправлена опечатка*. Это сообщение даёт мало информации. В такой коммит придётся «заглядывать» — разбираться, что именно поменялось и зачем. 


*to be continue.*